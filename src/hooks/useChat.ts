import { useState, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { addressValidator, formatDistance } from "@/lib/addressValidator";
import type { 
  ChatState, 
  AddressSuggestion, 
  AddressValidationResult, 
  LocationValidationResult,
  ChatMessage
} from "@/types/address";

const OPENAI_API_KEY = import.meta.env.VITE_OPENAI_API_KEY;

const SYSTEM_PROMPT = `Eres el asistente de Pollos Andino, una poller√≠a colombiana. Responde de forma natural, breve y amigable como un vendedor real.

TIENES ACCESO COMPLETO A LA BASE DE DATOS PARA:
‚úÖ Consultar puntos de clientes por c√©dula
‚úÖ Mostrar productos disponibles y precios actuales
‚úÖ Consultar sedes, direcciones y horarios
‚úÖ Crear pedidos con validaci√≥n geogr√°fica autom√°tica
‚úÖ Registrar clientes nuevos autom√°ticamente

DETECCI√ìN EXACTA DE INTENCIONES:
1. PUNTOS: Solo si mencionan "puntos" (NUNCA confundir con "productos disponibles")
2. PRODUCTOS: Solo si mencionan "productos", "precios", "cu√°nto cuesta" SIN mencionar "puntos"  
3. SEDES: Solo si mencionan "sede", "direcci√≥n", "horario", nombre de ciudad
4. PEDIDOS: Solo si quieren "comprar", "pedir", "hacer pedido", "domicilio"

NUEVO: VALIDACI√ìN GEOGR√ÅFICA AUTOM√ÅTICA
- Para pedidos a domicilio, validas autom√°ticamente la direcci√≥n
- Solo entregas dentro del radio de 5km de las sedes
- Muestras opciones de sedes cercanas si est√° fuera del radio

IMPORTANTE: Usa SIEMPRE la informaci√≥n real de la base de datos, no inventes datos.`;

export function useChat() {
  const [messages, setMessages] = useState<ChatMessage[]>([
    {
      id: "welcome",
      message: "¬°Hola! Soy el asistente virtual de Pollos Andino. Puedo ayudarte con:\n\n‚Ä¢ Consultar tus puntos acumulados\n‚Ä¢ Ver disponibilidad de productos\n‚Ä¢ Informaci√≥n de nuestras sedes\n‚Ä¢ **Realizar pedidos con entrega a domicilio** üöö\n\n¬øEn qu√© puedo ayudarte hoy?",
      isUser: false,
      timestamp: new Date(),
      quickReplies: ['üçó Ver productos', 'üìç Pedido a domicilio', '‚≠ê Consultar puntos', 'üè™ Ver sedes']
    }
  ]);

  const [isLoading, setIsLoading] = useState(false);
  const [sessionId] = useState(() => Math.random().toString(36).substring(7));
  const [chatState, setChatState] = useState<ChatState>({ currentStep: 'initial' });
  const { toast } = useToast();

  // Auto-reset del estado despu√©s de 5 minutos de inactividad
  const resetChatStateTimeout = () => {
    setTimeout(() => {
      setChatState(prev => {
        if (prev.currentStep !== 'initial') {
          console.log('Auto-resetting chat state due to inactivity');
          return { currentStep: 'initial' };
        }
        return prev;
      });
    }, 300000); // 5 minutos
  };

  const addMessage = (message: Omit<ChatMessage, 'id'>) => {
    const newMessage: ChatMessage = {
      ...message,
      id: Date.now().toString()
    };
    setMessages(prev => [...prev, newMessage]);
  };

  const saveConversation = async (message: string, isUser: boolean) => {
    try {
      await supabase
        .from('conversaciones')
        .insert({
          session_id: sessionId,
          mensaje: message,
          es_usuario: isUser
        });
    } catch (error) {
      console.error('Error saving conversation:', error);
    }
  };

  // === L√ìGICA DE VALIDACI√ìN DE DIRECCIONES ===
  
  const handleAddressInput = async (userMessage: string) => {
    addMessage({
      message: 'üîç Validando tu direcci√≥n...',
      isUser: false,
      timestamp: new Date()
    });

    try {
      const validationResult = await addressValidator.validateAddress(userMessage);
      await handleAddressValidationResult(validationResult, userMessage);
    } catch (error) {
      console.error('Address validation error:', error);
      addMessage({
        message: '‚ö†Ô∏è Tengo problemas verificando la direcci√≥n. ¬øPodr√≠as intentar de nuevo?',
        isUser: false,
        timestamp: new Date(),
        quickReplies: ['üîÑ Intentar de nuevo', 'üìû Hablar con agente']
      });
      // Resetear estado para permitir otras consultas
      setChatState({ currentStep: 'initial' });
    }
  };

  const handleAddressValidationResult = async (result: AddressValidationResult, originalInput: string) => {
    const confirmationResponse = addressValidator.generateConfirmationResponse(result, originalInput);
    
    addMessage({
      message: confirmationResponse.message,
      isUser: false,
      timestamp: new Date(),
      quickReplies: confirmationResponse.quickReplies,
      metadata: {
        addressSuggestions: confirmationResponse.suggestions || (confirmationResponse.addressData ? [confirmationResponse.addressData] : [])
      }
    });

    if (result.isValid) {
      setChatState({
        currentStep: 'confirming_address',
        pendingAddress: { 
          original: originalInput, 
          suggestions: confirmationResponse.suggestions || [confirmationResponse.addressData!].filter(Boolean)
        }
      });
    } else {
      setChatState({ currentStep: 'waiting_for_address' });
    }
  };

  const handleAddressConfirmation = async (userResponse: string) => {
    console.log('Processing address confirmation:', userResponse);
    const { pendingAddress } = chatState;
    if (!pendingAddress) {
      console.log('No pending address found');
      return;
    }

    const lowerResponse = userResponse.toLowerCase();
    
    // Detectar confirmaci√≥n positiva - ampliado para capturar m√°s variaciones
    const isConfirmation = lowerResponse.includes('s√≠') || 
                         lowerResponse.includes('si') ||
                         lowerResponse.includes('correcta') ||
                         lowerResponse.includes('correcto') ||
                         lowerResponse.includes('confirmado') ||
                         lowerResponse.includes('confirmo') ||
                         lowerResponse.includes('‚úÖ') ||
                         lowerResponse.includes('ok') ||
                         lowerResponse.includes('bien');

    // Detectar rechazo
    const isRejection = lowerResponse.includes('no') || 
                       lowerResponse.includes('‚ùå') ||
                       lowerResponse.includes('incorrecto') ||
                       lowerResponse.includes('incorrecta');

    if (isConfirmation) {
      console.log('User confirmed address, starting location validation');
      // Usuario confirm√≥ la direcci√≥n
      const confirmedAddress = pendingAddress.suggestions[0];
      setChatState(prev => ({
        ...prev,
        currentStep: 'validating_location',
        pendingAddress: { ...prev.pendingAddress!, confirmed: confirmedAddress }
      }));
      
      await validateDeliveryRadius(confirmedAddress);
      
    } else if (isRejection) {
      console.log('User rejected address, asking for new one');
      // Usuario rechaz√≥ - pedir direcci√≥n de nuevo
      setChatState({ currentStep: 'waiting_for_address' });
      addMessage({
        message: 'üìù Por favor, escribe tu direcci√≥n de nuevo con m√°s detalles:\n\nüí° Ejemplo: Carrera 15 # 93-07, Chapinero, Bogot√°',
        isUser: false,
        timestamp: new Date()
      });
      
    } else if (['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£'].includes(userResponse)) {
      console.log('User selected option:', userResponse);
      // Usuario seleccion√≥ una opci√≥n espec√≠fica
      const selectedIndex = parseInt(userResponse[0]) - 1;
      const selectedAddress = pendingAddress.suggestions[selectedIndex];
      
      if (selectedAddress) {
        setChatState(prev => ({
          ...prev,
          currentStep: 'validating_location',
          pendingAddress: { ...prev.pendingAddress!, confirmed: selectedAddress }
        }));
        
        await validateDeliveryRadius(selectedAddress);
      }
    } else {
      console.log('Response not recognized, prompting again');
      // Respuesta no reconocida - pedir confirmaci√≥n m√°s clara
      addMessage({
        message: 'ü§î No entend√≠ tu respuesta. Por favor confirma:\n\n¬øEs correcta esta direcci√≥n?\n\n‚Ä¢ Escribe "S√≠" para confirmar\n‚Ä¢ Escribe "No" para corregir',
        isUser: false,
        timestamp: new Date(),
        quickReplies: ['‚úÖ S√≠, es correcta', '‚ùå No, corregir']
      });
    }
  };

  const validateDeliveryRadius = async (confirmedAddress: AddressSuggestion) => {
    addMessage({
      message: 'üìç Verificando cobertura de entrega...',
      isUser: false,
      timestamp: new Date()
    });

    try {
      console.log('Starting location validation for:', confirmedAddress);
      const validationResult = await addressValidator.validateLocation(confirmedAddress);
      console.log('Location validation result:', validationResult);

      if (validationResult.within_radius) {
        // ‚úÖ Dentro del radio - continuar con pedido
        addMessage({
          message: `üéâ ¬°Perfecto! Hacemos entregas en tu zona.\n\n` +
                  `üè™ Sede m√°s cercana: **${validationResult.nearest_sede.nombre}**\n` +
                  `üìè Distancia: ${formatDistance(validationResult.distance_meters)}\n` +
                  `‚è∞ Tiempo estimado: ${validationResult.estimated_delivery_time}\n\n` +
                  `Ahora necesito algunos datos para tu pedido:\nüìù Escribe: **nombre, tel√©fono, producto**\n\nüí° Ejemplo: Juan P√©rez, 3001234567, pollo entero`,
          isUser: false,
          timestamp: new Date(),
          quickReplies: ['üçó Ver productos disponibles']
        });

        setChatState(prev => ({
          ...prev,
          currentStep: 'taking_order',
          deliveryInfo: {
            address: confirmedAddress,
            sede: validationResult.nearest_sede,
            distance: validationResult.distance_meters
          }
        }));

      } else {
        // ‚ùå Fuera del radio - mostrar alternativas
        const alternativesText = validationResult.nearest_sedes
          .slice(0, 2)
          .map(sede => `üìç **${sede.nombre}**: ${sede.direccion} (${formatDistance(sede.distance_meters)})`)
          .join('\n');

        addMessage({
          message: `üòî Lo sentimos, tu direcci√≥n est√° fuera de nuestra zona de entrega.\n\n` +
                  `üìè Distancia a la sede m√°s cercana: ${formatDistance(validationResult.distance_meters)}\n` +
                  `üöö Nuestro radio m√°ximo es de 5km\n\n` +
                  `**Sedes m√°s cercanas:**\n${alternativesText}\n\n` +
                  `üí° ¬øTe gustar√≠a recoger tu pedido en alguna de estas sedes?`,
          isUser: false,
          timestamp: new Date(),
          quickReplies: ['üè™ Ver todas las sedes', 'üìù Cambiar direcci√≥n', 'üìû Hablar con agente']
        });

        setChatState({ currentStep: 'initial' });
      }

    } catch (error) {
      console.error('Error validating delivery radius:', error);
      addMessage({
        message: '‚ö†Ô∏è Hubo un error verificando la cobertura. Por favor intenta de nuevo.',
        isUser: false,
        timestamp: new Date(),
        quickReplies: ['üîÑ Reintentar', 'üìû Hablar con agente']
      });
      
      // Resetear estado para permitir continuar
      setChatState({ currentStep: 'initial' });
    }
  };

  const handleOrderInput = async (userMessage: string): Promise<string> => {
    console.log('Processing order input:', userMessage);
    
    // Check if the message contains comma-separated data (nombre, telefono, producto)
    if (userMessage.includes(',')) {
      const parts = userMessage.split(',').map(p => p.trim());
      
      if (parts.length >= 2) {
        const nombre = parts[0];
        const telefono = parts[1];
        const producto = parts[2] || 'pollo entero';
        
        // Validate phone number format
        if (telefono.match(/\d{10}/)) {
          // Calculate price based on product
          let total = 15000;
          const productoLower = producto.toLowerCase();
          
          if (productoLower.includes('pechuga')) total = 18000;
          else if (productoLower.includes('muslos')) total = 12000;
          else if (productoLower.includes('alas')) total = 8000;
          else if (productoLower.includes('huevos aa')) total = 12000;
          else if (productoLower.includes('huevos campesinos')) total = 8000;
          
          const numeroPedido = `PL${Date.now()}`;
          
          try {
            // Register/update client
            await supabase.from('clientes').upsert({
              cedula: telefono,
              nombre: nombre,
              telefono: telefono,
              email: `${nombre.toLowerCase().replace(/\s+/g, '')}@temp.com`,
              puntos_acumulados: 0
            });
            
            // Create order
            const { error: pedidoError } = await supabase.from('pedidos').insert({
              numero_pedido: numeroPedido,
              cliente_cedula: telefono,
              cliente_nombre: nombre,
              cliente_telefono: telefono,
              cliente_email: `${nombre.toLowerCase().replace(/\s+/g, '')}@temp.com`,
              direccion_entrega: chatState.deliveryInfo!.address.formatted,
              latitud_entrega: chatState.deliveryInfo!.address.coordinates.lat,
              longitud_entrega: chatState.deliveryInfo!.address.coordinates.lng,
              sede_asignada: chatState.deliveryInfo!.sede.id,
              validacion_geografica: true,
              distancia_metros: chatState.deliveryInfo!.distance,
              productos: { detalle: producto, precio_unitario: total },
              total: total,
              estado: 'pendiente_pago'
            });

            if (!pedidoError) {
              const linkPago = `https://pagos.pollosandino.com/pagar/${numeroPedido}`;
              
              // Reset state to allow new orders
              setChatState({ currentStep: 'initial' });
              
              return `¬°Listo ${nombre}! üêî\n\n` +
                     `**Pedido #${numeroPedido}**\n` +
                     `${producto.charAt(0).toUpperCase() + producto.slice(1)} - $${total.toLocaleString('es-CO')}\n\n` +
                     `üìç **Entrega en:** ${chatState.deliveryInfo!.address.formatted}\n` +
                     `üè™ **Desde sede:** ${chatState.deliveryInfo!.sede.nombre}\n` +
                     `üìè **Distancia:** ${formatDistance(chatState.deliveryInfo!.distance)}\n` +
                     `‚è∞ **Tiempo estimado:** ${chatState.deliveryInfo!.sede.nombre.includes('Bogot√°') ? '25-35' : '30-40'} minutos\n\n` +
                     `üí≥ **Link de pago:**\n${linkPago}\n\n` +
                     `¬øAlgo m√°s en lo que pueda ayudarte?`;
            } else {
              return `‚ùå Error al crear el pedido. Ll√°manos al ${chatState.deliveryInfo?.sede.telefono || '(4) 123-4567'}`;
            }
          } catch (error) {
            console.error('Error creating order:', error);
            return `‚ùå Error al crear el pedido. Ll√°manos al ${chatState.deliveryInfo?.sede.telefono || '(4) 123-4567'}`;
          }
        } else {
          return `üì± El tel√©fono debe tener 10 d√≠gitos. Por favor intenta de nuevo:\n\nüìù Formato: nombre, tel√©fono, producto\nüí° Ejemplo: Juan P√©rez, 3001234567, pollo entero`;
        }
      } else {
        return `üìù Necesito m√°s informaci√≥n. Por favor usa este formato:\n\n**nombre, tel√©fono, producto**\nüí° Ejemplo: Juan P√©rez, 3001234567, pollo entero`;
      }
    } else {
      // Handle single responses or quick replies
      if (userMessage.toLowerCase().includes('productos disponibles') || userMessage.toLowerCase().includes('ver productos')) {
        try {
          const { data: productos } = await supabase
            .from('productos')
            .select('*')
            .eq('activo', true);

          if (productos && productos.length > 0) {
            let response = 'üêî **PRODUCTOS DISPONIBLES:**\n\n';
            productos.forEach(prod => {
              const disponible = prod.stock > 0 ? '‚úÖ Disponible' : '‚ùå Agotado';
              response += `**${prod.nombre}**: $${prod.precio.toLocaleString('es-CO')} - ${disponible}\n`;
            });
            response += '\nüìù Para hacer tu pedido, escribe:\n**nombre, tel√©fono, producto**\nüí° Ejemplo: Juan P√©rez, 3001234567, pollo entero';
            return response;
          }
        } catch (error) {
          return 'Error consultando productos. Ll√°manos al (4) 123-4567';
        }
      }
      
      return `üìù Para continuar con tu pedido, necesito estos datos en este formato:\n\n**nombre, tel√©fono, producto**\nüí° Ejemplo: Juan P√©rez, 3001234567, pollo entero\n\nüçó O escribe "ver productos" para ver el men√∫ disponible`;
    }
  };

  // === L√ìGICA EXISTENTE MODIFICADA ===

  const processSpecialCases = async (userMessage: string): Promise<string | null> => {
    const lowerMessage = userMessage.toLowerCase();

    // Comando de escape: permitir salir del flujo de direcciones
    if (['cancelar', 'salir', 'menu', 'inicio', 'volver'].some(cmd => lowerMessage.includes(cmd))) {
      setChatState({ currentStep: 'initial' });
      return "¬°Perfecto! ¬øEn qu√© m√°s puedo ayudarte?\n\n‚Ä¢ üçó Ver productos\n‚Ä¢ üìç Pedido a domicilio\n‚Ä¢ ‚≠ê Consultar puntos\n‚Ä¢ üè™ Ver sedes";
    }

    // Manejo espec√≠fico de "Cambiar direcci√≥n"
    if (lowerMessage.includes('cambiar direcci√≥n') || lowerMessage.includes('cambiar direccion')) {
      setChatState({ currentStep: 'waiting_for_address' });
      return "üìù Perfecto, escribe tu nueva direcci√≥n completa:\n\nüí° Ejemplo: Carrera 15 # 93-07, Chapinero, Bogot√°";
    }

    // Manejo de estados de direcci√≥n
    if (chatState.currentStep === 'waiting_for_address') {
      await handleAddressInput(userMessage);
      return "HANDLED";
    }

    if (chatState.currentStep === 'confirming_address') {
      await handleAddressConfirmation(userMessage);
      return "HANDLED";
    }

    if (chatState.currentStep === 'taking_order') {
      return await handleOrderInput(userMessage);
    }

    // Handle order input from users who haven't gone through address validation
    if (userMessage.includes(',') && chatState.currentStep === 'initial') {
      const parts = userMessage.split(',').map(p => p.trim());
      
      if (parts.length >= 2) {
        const nombre = parts[0];
        
        addMessage({
          message: `Perfecto ${nombre}, ahora necesito tu direcci√≥n completa para verificar si hacemos entrega en tu zona.\n\nüìù Por favor escribe tu direcci√≥n completa:\nüí° Ejemplo: Carrera 15 # 93-07, Chapinero, Bogot√°`,
          isUser: false,
          timestamp: new Date()
        });
        
        setChatState({ currentStep: 'waiting_for_address' });
        return "HANDLED";
      }
    }

    // Detecci√≥n de intenci√≥n de pedido a domicilio
    if ((lowerMessage.includes('pedido') || lowerMessage.includes('pedir') || lowerMessage.includes('domicilio') || 
         lowerMessage.includes('entrega') || lowerMessage.includes('üìç') || lowerMessage.includes('hacer pedido')) && 
         chatState.currentStep === 'initial') {
      
      addMessage({
        message: 'üçó ¬°Perfecto! Para hacer tu pedido con entrega a domicilio necesito validar la direcci√≥n.\n\nüìù Por favor escribe tu direcci√≥n completa:\nüí° Ejemplo: Carrera 15 # 93-07, Chapinero, Bogot√°',
        isUser: false,
        timestamp: new Date()
      });
      
      setChatState({ currentStep: 'waiting_for_address' });
      return "HANDLED";
    }

    // 2. CONSULTA DE PUNTOS (MANTENER L√ìGICA EXISTENTE)
    if (lowerMessage.includes('puntos') && !lowerMessage.includes('productos')) {
      const cedulaMatch = userMessage.match(/\d{7,10}/);
      if (!cedulaMatch) {
        return `Para consultar tus puntos necesito tu c√©dula. ¬øMe la puedes dar?`;
      }
      
      const cedula = cedulaMatch[0];
      try {
        const { data: cliente } = await supabase
          .from('clientes')
          .select('nombre, puntos_acumulados')
          .eq('cedula', cedula)
          .single();

        if (cliente) {
          return `¬°Hola ${cliente.nombre}! üéâ\n\nTus puntos acumulados: **${cliente.puntos_acumulados} puntos**\n\n¬øTe ayudo con algo m√°s?`;
        } else {
          return `No encontr√© la c√©dula ${cedula}. ¬øQuieres registrarte? Solo dime: nombre, tel√©fono, direcci√≥n`;
        }
      } catch (error) {
        return `Error consultando puntos. Intenta de nuevo.`;
      }
    }

    // 2b. CONSULTA DE PUNTOS SOLO CON C√âDULA
    const cedulaSolaMatch = userMessage.match(/^\d{7,10}$/);
    if (cedulaSolaMatch) {
      const cedula = cedulaSolaMatch[0];
      try {
        const { data: cliente } = await supabase
          .from('clientes')
          .select('nombre, puntos_acumulados')
          .eq('cedula', cedula)
          .single();

        if (cliente) {
          return `¬°Hola ${cliente.nombre}! üéâ\n\nTus puntos acumulados: **${cliente.puntos_acumulados} puntos**\n\n¬øTe ayudo con algo m√°s?`;
        } else {
          return `No encontr√© la c√©dula ${cedula}. ¬øQuieres registrarte haciendo un pedido?`;
        }
      } catch (error) {
        return `Error consultando puntos. Intenta de nuevo.`;
      }
    }

    // 3. CONSULTA DE PRODUCTOS (MANTENER L√ìGICA EXISTENTE)
    if ((lowerMessage.includes('producto') || lowerMessage.includes('disponib') || lowerMessage.includes('precio') || 
         lowerMessage.includes('pollo') && (lowerMessage.includes('cuesta') || lowerMessage.includes('precio')) ||
         lowerMessage.includes('cu√°nto') || lowerMessage.includes('cuanto')) && 
         !lowerMessage.includes('puntos')) {
      try {
        const { data: productos } = await supabase
          .from('productos')
          .select('*')
          .eq('activo', true);

        if (productos && productos.length > 0) {
          let response = 'üêî **PRODUCTOS DISPONIBLES:**\n\n';
          productos.forEach(prod => {
            const disponible = prod.stock > 0 ? '‚úÖ Disponible' : '‚ùå Agotado';
            response += `**${prod.nombre}**: $${prod.precio.toLocaleString('es-CO')} - ${disponible}\n`;
          });
          response += '\n¬øQuieres hacer un pedido a domicilio? üöö';
          return response;
        }
      } catch (error) {
        return 'Error consultando productos. Ll√°manos al (4) 123-4567';
      }
    }

    // 4. CONSULTA DE SEDES (MANTENER L√ìGICA EXISTENTE)
    if (lowerMessage.includes('sede') || lowerMessage.includes('direcci√≥n') || lowerMessage.includes('direccion') || 
        lowerMessage.includes('ubicaci√≥n') || lowerMessage.includes('ubicacion') || lowerMessage.includes('horario') ||
        lowerMessage.includes('medell√≠n') || lowerMessage.includes('medellin') || lowerMessage.includes('bogot√°') || 
        lowerMessage.includes('bogota') || lowerMessage.includes('cali') || lowerMessage.includes('barranquilla')) {
      try {
        const { data: sedes } = await supabase
          .from('sedes')
          .select('*')
          .eq('activa', true);

        if (sedes && sedes.length > 0) {
          let response = 'üìç **NUESTRAS SEDES:**\n\n';
          sedes.forEach(sede => {
            response += `**${sede.nombre}**\nüè† ${sede.direccion}\n‚è∞ ${sede.horario}\nüìû ${sede.telefono}\n\n`;
          });
          response += '¬øTe ayudo con algo m√°s?';
          return response;
        }
      } catch (error) {
        return 'Error consultando sedes. Ll√°manos al (4) 123-4567';
      }
    }

    return null;
  };

  const sendMessage = useCallback(async (userMessage: string) => {
    console.log('Sending message:', userMessage);
    console.log('Current chat state:', chatState);
    
    const newUserMessage: ChatMessage = {
      id: Date.now().toString(),
      message: userMessage,
      isUser: true,
      timestamp: new Date()
    };

    setMessages(prev => [...prev, newUserMessage]);
    setIsLoading(true);

    await saveConversation(userMessage, true);

    try {
      const specialResponse = await processSpecialCases(userMessage);
      console.log('Special response result:', specialResponse);
      
      if (specialResponse && specialResponse !== "HANDLED") {
        const aiMessage: ChatMessage = {
          id: (Date.now() + 1).toString(),
          message: specialResponse,
          isUser: false,
          timestamp: new Date()
        };
        setMessages(prev => [...prev, aiMessage]);
        await saveConversation(specialResponse, false);
      } else if (specialResponse !== "HANDLED") {
        // Usar OpenAI para otros casos generales
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${OPENAI_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              { role: 'system', content: SYSTEM_PROMPT },
              ...messages.slice(-5).map(msg => ({
                role: msg.isUser ? 'user' : 'assistant',
                content: msg.message
              })),
              { role: 'user', content: userMessage }
            ],
            temperature: 0.7,
            max_tokens: 600
          }),
        });

        const data = await response.json();
        const aiResponse = data.choices[0].message.content;
        
        const aiMessage: ChatMessage = {
          id: (Date.now() + 1).toString(),
          message: aiResponse,
          isUser: false,
          timestamp: new Date()
        };

        setMessages(prev => [...prev, aiMessage]);
        await saveConversation(aiResponse, false);
      }

    } catch (error) {
      console.error('Error sending message:', error);
      
      const errorMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        message: "Lo siento, hubo un error al procesar tu mensaje. Por favor intenta nuevamente.",
        isUser: false,
        timestamp: new Date()
      };

      setMessages(prev => [...prev, errorMessage]);
      
      toast({
        title: "Error",
        description: "No se pudo enviar el mensaje. Verifica tu conexi√≥n e intenta nuevamente.",
        variant: "destructive"
      });
    } finally {
      setIsLoading(false);
    }
  }, [messages, sessionId, chatState, toast]);

  return {
    messages,
    isLoading,
    sendMessage,
    chatState,
    setChatState
  };
}